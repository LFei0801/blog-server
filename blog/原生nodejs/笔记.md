## 登录方案
* 核心： 登录检验 & 登录信息存储
* cookie 登录基础，session 实现登录的通用解决方案
* session 写入redis
* 开发登录功能，和前端联调（用nginx反向代理）

## 1. cookie
**cookie跨域不共享** <br>
格式： k1=v1;k2=v2;k3=v3<br>
每次发送http请求，会将请求域的cookie一起发送给server<br>
server端可以修改cookie,并返回给浏览器<br>
浏览器可以通过JS修改Cookie

### 1.2  使用 cookie进行登录检验
思路，就是前端登录时，后端将其登录成功的用户名用Cookie记录一下，并返回给前端<br>
首先解析Cookie数据,将其绑定在req,cookie对象属性上
```js
const parseCookie = (res)=>{
  req.cookie = {}
  const cookieStr = res.headers.cookie
  cookieStr.split(";").forEach(item=>{
    if(!item) return
    const [key,value] = item.split("=")
    req.cookie[key.trim()] = value.trim()
  })
}
```

然后在登录接口中，设置cookie
```js
/**** router/user.js 文件 *****/
if(req.method === 'POST' && req.path === '/api/login'){
  const {username,password} = req.body
  return login(username,password).then(data=>{
    if(data.username){
      // 设置cookie
      res.setHeader('Set-Cookie',`username=${data.username};path=/;`)
      return new SuccessModal("登录成功")
    }
    return new ErrorModal("登录失败，用户不存在")
  })
}
```

### 1.3 限制前端修改cookie
前端可以设置cookie，这样就可以伪造登录信息，因此必须限制前端操作cookie<br>
只需要在后端返回的cookie中加上httpOnly即可
```js
res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;`)
```

###  1.4 设置cookie过期时间
expries=过期时间<br>
比如。设置一天后Cookie失效
```js
// 获取过期时间函数
const getCookieExpires = ()=>{
  const date = new Date()
  date.setTime(date.getTime() + (24 * 60 * 60 * 1000)) 
  return date.toUTCString()
}

// 设置cookie过期时间
res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;expries=${getCookieExpires()}`)
```

### 1.5 cookie总结
cookie 使用一种形如 k1=v1;k2=v2;这种格式的字符串存储在浏览器中，前后端都能操作cookie,且跨域不共享<br>
因此，用Cookie做登录验证的步骤如下：
1. 通过req.headers.cookie获取cookie,在根据Cookie格式的特点，通过字符串方法split将其拆分成{k1:v1,k2:v2}这种对象格式
2. 将这种对象格式绑定在req.cookie上，方便后续操作
3. 在登录时，通过 res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;expires=time`)
这种返回Cookie给前端，并做一定的限制
4. 限制如下：httpOnly是为了前端修改cookie,expires是为了设置cookie过期时间，path=/是为了在当前页面都使用此cookie

**Cookie有一个显著的缺点，就是会暴露用户的信息，比如username,只要懂一点点技术的人，就可以在浏览器中查看用户信息**<br>
**解决思路：cookie存储用户id,后端对应用户密码**

## 2. session
cookie存储用户标识，server端将这种标识对应用户信息

解决基本思路：
```js
/***utils/index.js**/
const SESSION_DATA = {}  // SESSION_DATA全局对象
const parseSession = (req) => {
  // 当前端请求的cookie中没有useid这个字段时才会需要重新在后端设置cookie
  let needSetCookie = false
  let userid = req.cookie.userid
  if(userid){
    // SESSON_DATA中没有userid这个字段时，初始化这个字段
    if(!SESSION_DATA[userid]){
      SESSION_DATA[userid] = {}
    }
  }else{
    needSetCookie = true
    userid = `${Date.now()}_${Math.random()}`
    SESSION_DATA[userid] = userId
  }
  // 绑定到req.session中
  req.session = SESSION_DATA[userid]
  return { needSetCookie,userid }
}

/**app.js*/
const { needSetCookie,userid } = parseSession()
// 用户路由
const userData = await handleUserRoute(req,res)
if(userData){
  if(needSetCookie){
    console.log("userid is ",userid)
    res.setHeader('Set-Cookie',`userid=${userid};path=/;httpOnly;expires=${getCookieExpires()}`)
  }
  res.end(JSON.stringify(userData))
  return;
}

/***router/user.js 文件 **/
if(req.method === 'GET' && req.path === '/api/user/login'){
  const {username,password} = req.query
  return login(username,password).then(data=>{
    if(data.username){
      // 设置session数据，相当于 SESSON_DATA = {userid:data.username}
      req.session.username = data.username
      return new SuccessModal('登录成功')
    }
    return new ErrorModal('登录失败')
  })
}

if(req.method === 'GET' && req.path === '/api/user/login-test'){
  if(req.session.username){
    return new SuccessModal(req.session)
  }
  return new ErrorModal('尚未登录')
}
``` 