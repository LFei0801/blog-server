## 登录方案
* 核心： 登录检验 & 登录信息存储
* cookie 登录基础，session 实现登录的通用解决方案
* session 写入redis
* 开发登录功能，和前端联调（用nginx反向代理）

## 1. cookie
**cookie跨域不共享** <br>
格式： k1=v1;k2=v2;k3=v3<br>
每次发送http请求，会将请求域的cookie一起发送给server<br>
server端可以修改cookie,并返回给浏览器<br>
浏览器可以通过JS修改Cookie

### 1.2  使用 cookie进行登录检验
思路，就是前端登录时，后端将其登录成功的用户名用Cookie记录一下，并返回给前端<br>
首先解析Cookie数据,将其绑定在req,cookie对象属性上
```js
const parseCookie = (res)=>{
  req.cookie = {}
  const cookieStr = res.headers.cookie
  cookieStr.split(";").forEach(item=>{
    if(!item) return
    const [key,value] = item.split("=")
    req.cookie[key.trim()] = value.trim()
  })
}
```

然后在登录接口中，设置cookie
```js
/**** router/user.js 文件 *****/
if(req.method === 'POST' && req.path === '/api/login'){
  const {username,password} = req.body
  return login(username,password).then(data=>{
    if(data.username){
      // 设置cookie
      res.setHeader('Set-Cookie',`username=${data.username};path=/;`)
      return new SuccessModal("登录成功")
    }
    return new ErrorModal("登录失败，用户不存在")
  })
}
```

### 1.3 限制前端修改cookie
前端可以设置cookie，这样就可以伪造登录信息，因此必须限制前端操作cookie<br>
只需要在后端返回的cookie中加上httpOnly即可
```js
res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;`)
```

###  1.4 设置cookie过期时间
expries=过期时间<br>
比如。设置一天后Cookie失效
```js
// 获取过期时间函数
const getCookieExpires = ()=>{
  const date = new Date()
  date.setTime(date.getTime() + (24 * 60 * 60 * 1000)) 
  return date.toUTCString()
}

// 设置cookie过期时间
res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;expries=${getCookieExpires()}`)
```

### 1.5 cookie总结
cookie 使用一种形如 k1=v1;k2=v2;这种格式的字符串存储在浏览器中，前后端都能操作cookie,且跨域不共享<br>
因此，用Cookie做登录验证的步骤如下：
1. 通过req.headers.cookie获取cookie,在根据Cookie格式的特点，通过字符串方法split将其拆分成{k1:v1,k2:v2}这种对象格式
2. 将这种对象格式绑定在req.cookie上，方便后续操作
3. 在登录时，通过 res.setHeader(`Set-Cookie','username=${data.username};path=/;httpOnly;expires=time`)
这种返回Cookie给前端，并做一定的限制
4. 限制如下：httpOnly是为了前端修改cookie,expires是为了设置cookie过期时间，path=/是为了在当前页面都使用此cookie

**Cookie有一个显著的缺点，就是会暴露用户的信息，比如username,只要懂一点点技术的人，就可以在浏览器中查看用户信息**<br>
**解决思路：cookie存储用户id,后端对应用户密码**

## 2. session
cookie存储用户标识，server端将这种标识对应用户信息

解决基本思路：
```js
/***utils/index.js**/
const SESSION_DATA = {}  // SESSION_DATA全局对象
const parseSession = (req) => {
  // 当前端请求的cookie中没有useid这个字段时才会需要重新在后端设置cookie
  let needSetCookie = false
  let userid = req.cookie.userid
  if(userid){
    // SESSON_DATA中没有userid这个字段时，初始化这个字段
    if(!SESSION_DATA[userid]){
      SESSION_DATA[userid] = {}
    }
  }else{
    needSetCookie = true
    userid = `${Date.now()}_${Math.random()}`
    SESSION_DATA[userid] = userId
  }
  // 绑定到req.session中
  req.session = SESSION_DATA[userid]
  return { needSetCookie,userid }
}

/**app.js*/
const { needSetCookie,userid } = parseSession()
// 用户路由
const userData = await handleUserRoute(req,res)
if(userData){
  if(needSetCookie){
    console.log("userid is ",userid)
    res.setHeader('Set-Cookie',`userid=${userid};path=/;httpOnly;expires=${getCookieExpires()}`)
  }
  res.end(JSON.stringify(userData))
  return;
}

/***router/user.js 文件 **/
if(req.method === 'GET' && req.path === '/api/user/login'){
  const {username,password} = req.query
  return login(username,password).then(data=>{
    if(data.username){
      // 设置session数据，相当于 SESSON_DATA = {userid:data.username}
      req.session.username = data.username
      return new SuccessModal('登录成功')
    }
    return new ErrorModal('登录失败')
  })
}

if(req.method === 'GET' && req.path === '/api/user/login-test'){
  if(req.session.username){
    return new SuccessModal(req.session)
  }
  return new ErrorModal('尚未登录')
}
``` 

**这样是将session当前JS变量进行存储，直接存储在内存中，但是用户暴增时，内存就容易挤爆！**

## 3. redis数据库
redis是一个内存数据库，访问速度快。
1. session 访问频繁，对性能要求很高
2. session 不考虑断电丢失数据的问题
3. session 数据量不会太大

为什么不把数据都放在redis中呢？
1. 有些数据操作频率不是太高，比如博客数据发表之后，就只需要增删改查即可，但是相对而言不会很高。
2. 断电不能丢失，必须保留
3. 数据量大，内存成本太高

### 3.1 redis基本使用
打开redis服务：
```
cd D://redis
.\redis.server.exe
```
连接redis服务：
```
新建终端,注意不要关闭redis服务终端
执行： .\redis-cli.exe -h 127.0.0.1 -p 6379
```
redis是一个key-value数据库，操作数据通过set和get来操作
```
//设置 数据 
set myname lfly
//读取数据
get myname
// 查询所有数据
keys *
// 删除数据
del myname 
```

### 3.2 封装redis
```js
const redis = require('redis')
const {REDIS_CONFIG} = require("../config/db");

// 创建客户端
const redisClient = redis.createClient(REDIS_CONFIG.port,REDIS_CONFIG.host)
redisClient.on('error',err => console.error(err))

function set(key,val){
  redisClient.set(key,JSON.stringify(val),redis.print)
}

function get(key){
  return new Promise((resolve, reject) => {
    redisClient.get(key,(err,val)=>{
      if(err){
        reject(err)
        return
      }

      // key-value不存在时，返回null
      if(typeof val == null){
        resolve(null)
        return
      }

      // 尝试将val解析，如果不是JSON格式的数据就直接返回val
      try{
        resolve(JSON.parse(val))
      }catch (e){
        resolve(val)
      }
    })
  })
}

module.exports = {
  set,
  get
}
```